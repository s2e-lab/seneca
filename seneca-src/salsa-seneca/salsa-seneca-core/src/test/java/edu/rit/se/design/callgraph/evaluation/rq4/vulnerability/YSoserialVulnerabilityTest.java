package edu.rit.se.design.callgraph.evaluation.rq4.vulnerability;

import com.ibm.wala.ipa.callgraph.*;
import com.ibm.wala.ipa.callgraph.propagation.InstanceKey;
import com.ibm.wala.ipa.cha.ClassHierarchyException;
import com.ibm.wala.ipa.cha.IClassHierarchy;
import com.ibm.wala.ipa.slicer.*;
import com.ibm.wala.ssa.SSAInstruction;
import com.ibm.wala.ssa.SSAInvokeInstruction;
import com.ibm.wala.ssa.SymbolTable;
import com.ibm.wala.types.ClassLoaderReference;
import com.ibm.wala.types.MethodReference;
import com.ibm.wala.util.CancelException;
import com.ibm.wala.util.collections.Pair;
import com.ibm.wala.util.graph.NumberedGraph;
import edu.rit.se.design.callgraph.analysis.AbstractSerializationCallGraphBuilder;
import edu.rit.se.design.callgraph.analysis.PointerAnalysisPolicy;
import edu.rit.se.design.callgraph.evaluation.rq1_rq2.soundness_precision.XCorpusSoundnessTest;
import edu.rit.se.design.callgraph.evaluation.utils.YSoSerialTestCases;
import edu.rit.se.design.dodo.utils.graphs.IPathFinderIterative;
import edu.rit.se.design.dodo.utils.graphs.TrieBasedBFSPathFinderIterative;
import edu.rit.se.design.dodo.utils.wala.MethodDescriptorsLoader;
import edu.rit.se.design.dodo.utils.wala.SinkDescriptor;
import edu.rit.se.design.dodo.utils.wala.WalaUtils;
import org.apache.commons.io.FileUtils;
import org.junit.jupiter.api.DynamicTest;
import org.junit.jupiter.api.TestFactory;

import java.io.File;
import java.io.IOException;
import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import static edu.rit.se.design.callgraph.analysis.PointerAnalysisPolicy.PolicyType.ZeroXCFA;
import static edu.rit.se.design.callgraph.evaluation.rq1_rq2.soundness_precision.XCorpusSoundnessTest.*;
import static edu.rit.se.design.callgraph.evaluation.utils.TestUtilities.*;
import static edu.rit.se.design.callgraph.util.AnalysisUtils.*;
import static edu.rit.se.design.dodo.utils.wala.WalaUtils.methodToString;
import static java.lang.String.join;

public class YSoserialVulnerabilityTest {

    public static String[] projects = new String[]{
            YSoSerialTestCases.ASPECTJWEAVER,
            YSoSerialTestCases.BEANSHELL1,
            YSoSerialTestCases.C3P0,
            YSoSerialTestCases.CLICK1,
            YSoSerialTestCases.CLOJURE,
            YSoSerialTestCases.COMMONS_BEAN_UTILS1,
            YSoSerialTestCases.COMMONS_COLLECTIONS1,
            YSoSerialTestCases.COMMONS_COLLECTIONS2,
            YSoSerialTestCases.COMMONS_COLLECTIONS3,
            YSoSerialTestCases.COMMONS_COLLECTIONS4,
            YSoSerialTestCases.COMMONS_COLLECTIONS5,
            YSoSerialTestCases.COMMONS_COLLECTIONS6,
            YSoSerialTestCases.COMMONS_COLLECTIONS7,
//            YSoSerialTestCases.FILEUPLOAD1,
            YSoSerialTestCases.GROOVY1,
            YSoSerialTestCases.JAVASSIST_WELD1,
            YSoSerialTestCases.JBOSS_INTERCEPTORS1,
            YSoSerialTestCases.JSON1,
            YSoSerialTestCases.JYTHON1,
            YSoSerialTestCases.MOZILLA_RHINO1,
            YSoSerialTestCases.MOZILLA_RHINO2,
            YSoSerialTestCases.ROME,
            YSoSerialTestCases.SPRING1,
            YSoSerialTestCases.SPRING2,
            YSoSerialTestCases.VAADIN1,
            YSoSerialTestCases.WICKET1,
    };


    @TestFactory
    public Collection<DynamicTest> soundnessTests() throws IOException {
        List<SinkDescriptor> sinkDescriptors = MethodDescriptorsLoader.loadSinksFromCsv(new File("../../config/sinks.csv"), true);

        Collection<DynamicTest> dynamicTests = new ArrayList<>();

        for (String projectPath : projects) {
            for (XCorpusSoundnessTest.Approach algorithm : Arrays.asList(Approach.SALSA, Approach.SENECA)) {
                for (PointerAnalysisPolicy policy : Arrays.asList(new PointerAnalysisPolicy(ZeroXCFA, 1))) {
                    String projectName = getProjectName(projectPath);
                    String approachName = algorithm.toString();
                    String testName = join("_", projectName, approachName, policy.toString());
                    DynamicTest dTest = DynamicTest.dynamicTest(testName, () -> {
                        Pair<SDG<InstanceKey>, AbstractSerializationCallGraphBuilder> p = computeSDG(projectPath, algorithm, policy);
                        SDG sdg = p.fst;
                        AbstractSerializationCallGraphBuilder builder = p.snd;
                        List<Statement> sinkStatements = findSinks(sdg, sinkDescriptors);

                        List<VulnerablePath> vulnerablePaths = findAll(sdg, builder, sinkStatements);
                        StringBuilder results = new StringBuilder();
                        results.append("Found ").append(vulnerablePaths.size()).append(" potentially vulnerable paths.\n");
                        for (VulnerablePath vulnPath : vulnerablePaths) {
                            results.append("STATEMENT PATH #" + vulnPath.id + "\n");
                            CGNode priorNode = null;
                            for (Statement statement : vulnPath.path) {
                                CGNode currentNode = statement.getNode();
                                if (priorNode != currentNode) {
                                    priorNode = currentNode;
                                    results.append(String.format("\tNode#%d %s@%s",
                                            priorNode.getGraphNodeId(),
                                            methodToString(priorNode.getMethod().getReference()),
                                            priorNode.getContext())
                                    ).append("\n");
                                }
                                if (statement.getKind() == Statement.Kind.NORMAL) {
                                    SymbolTable symbolTable = priorNode.getIR().getSymbolTable();
                                    SSAInstruction instr = ((NormalStatement) statement).getInstruction();
                                    results.append("\t\t [iindex=").append(instr.iIndex()).append("]")
                                            .append(instr.toString(symbolTable)).append("\n");
                                } else {
                                    results.append("\t\t").append(statement).append("\n");
                                }
                            }
                        }

                        // writes the results
                        String fileName = join("_", projectName, approachName, policy.toString(), "vuln_paths.txt");
                        FileUtils.write(new File(VULN_PATHS_FOLDER, fileName), results.toString(), "UTF-8");
                    });
                    dynamicTests.add(dTest);
                }
            }
        }
        return dynamicTests;
    }

    /**
     * Given the project path, approach and pointer analysis policy, computes the SDG for the project.
     *
     * @param projectPath path to the YSoSerial project where we will find the JAR files added to the extension scope.
     * @param approach    the approach to be used to compute the call graph (eg {@link Approach#SENECA}).
     * @param policy      the pointer analysis policy to be used to compute the call graph (see {@link PointerAnalysisPolicy}).
     * @return the SDG for the project.
     * @throws ClassHierarchyException         if the class hierarchy could not be computed.
     * @throws IOException                     if the exclusions file could not be read.
     * @throws CallGraphBuilderCancelException if the call graph could not be computed.
     */
    public Pair<SDG<InstanceKey>, AbstractSerializationCallGraphBuilder> computeSDG(String projectPath, Approach approach, PointerAnalysisPolicy policy) throws ClassHierarchyException, IOException, CallGraphBuilderCancelException {
        File exclusions = new File(EXCLUSIONS_FILE);
        AnalysisScope scope = makeAnalysisScope(DRIVER_CLASS, exclusions, new File(projectPath));
        IClassHierarchy cha = makeIClassHierarchy(scope);
        AnalysisOptions options = makeAnalysisOptions(scope, cha);
        AnalysisCache cache = makeAnalysisCache();

        // compute call graph
        CallGraphBuilder builder = getCallgraphBuilder(approach, policy, scope, options, cache, cha);
        CallGraph cg = builder.makeCallGraph(options, null);

        // compute SDG
        SDG<InstanceKey> sdg = new SDG(cg, builder.getPointerAnalysis(), Slicer.DataDependenceOptions.NONE, Slicer.ControlDependenceOptions.NO_EXCEPTIONAL_EDGES);

        return Pair.make(sdg, ((AbstractSerializationCallGraphBuilder) builder));
    }


    private static List<Statement> findSinks(SDG<InstanceKey> sdg, List<SinkDescriptor> sinkDescriptors) {
        List<Statement> sinks = new ArrayList<>();
        for (Statement s : sdg) {
            if (s.getKind().equals(Statement.Kind.NORMAL) && !s.getNode().getMethod().getDeclaringClass().getClassLoader().getReference().equals(ClassLoaderReference.Primordial)) {
                SSAInstruction instruction = ((NormalStatement) s).getInstruction();
                if (instruction instanceof SSAInvokeInstruction) {
                    MethodReference declaredTarget = ((SSAInvokeInstruction) instruction).getDeclaredTarget();
                    sinkDescriptors.parallelStream()
                            .filter(sinkDesc -> sinkDesc.getMethodRef().getSignature().equals(declaredTarget.getSignature()))
                            .forEach(desc -> sinks.add(s));

                }
            }
        }
        return sinks;
    }


    public List<VulnerablePath> findAll(SDG<InstanceKey> sdg, AbstractSerializationCallGraphBuilder builder, List<Statement> sinkStatements) throws CancelException {
        List<VulnerablePath> results = new ArrayList<>();
        CallGraph cg = sdg.getCallGraph();

        int pathSizeThrehold = 100;
        // magic methods
        Set<Statement> magicMethods = builder.getMagicMethods().stream().map(MethodEntryStatement::new).collect(Collectors.toSet());

        int sinkNo = 0;
        for (Statement sinkStatement : sinkStatements) {
            sinkNo++;
            // compute backward slice
            Set<Statement> slice = new HashSet<>(Slicer.computeBackwardSlice(sdg, sinkStatement));
            Set<CGNode> allNodePaths = findAllNodePaths(sinkStatement, builder.getMagicMethods(), cg, 100);

            // attempts to find all paths within a callgraph
            NumberedGraph<Statement> prunedSdg = WalaUtils.prune(sdg, s -> !WalaUtils.isPrimordialScope(s) && slice.contains(s) && allNodePaths.contains(s.getNode()));
            Predicate<Statement> p = stmt -> stmt.equals(sinkStatement);
            IPathFinderIterative<Statement> finder = new TrieBasedBFSPathFinderIterative<Statement>(prunedSdg, p, magicMethods.iterator(), null);

            List<Statement> path;
            int nPaths = 0;
            while ((path = finder.find()) != null) {
                VulnerablePath vulnerablePath = new VulnerablePath(cg, sinkNo + "." + (++nPaths), path);
                results.add(vulnerablePath);
            }
        }
        return results;
    }


    /**
     * Finds all node-level path statements to sinks.
     * This search is bounded by the pathSizeThreshold attribute.
     *
     * @param sinkStatement the sink statement of choice
     * @return all node-level path
     */
    private Set<CGNode> findAllNodePaths(Statement sinkStatement, Set<CGNode> magicMethods, CallGraph cg, int pathSizeThreshold) {
        Set<CGNode> result = new HashSet<>();
        Predicate<CGNode> p = node -> node.equals(sinkStatement.getNode());
        IPathFinderIterative<CGNode> finder = new TrieBasedBFSPathFinderIterative<CGNode>(cg, p, magicMethods.iterator(), pathSizeThreshold);
        List<CGNode> path;
        while ((path = finder.find()) != null)
            result.addAll(path);
        return result;
    }

    static class VulnerablePath {

        // required fields
        public final CallGraph cg;
        public final String id;
        public final List<Statement> path;

        VulnerablePath(CallGraph cg, String pathId, List<Statement> path) {
            this.cg = cg;
            this.id = pathId;
            this.path = path;
        }
    }
}
