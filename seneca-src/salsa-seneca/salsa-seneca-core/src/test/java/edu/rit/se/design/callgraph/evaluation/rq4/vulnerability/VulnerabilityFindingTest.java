package edu.rit.se.design.callgraph.evaluation.rq4.vulnerability;


import com.ibm.wala.ipa.callgraph.*;
import com.ibm.wala.ipa.callgraph.propagation.InstanceKey;
import com.ibm.wala.ipa.cha.ClassHierarchyException;
import com.ibm.wala.ipa.cha.IClassHierarchy;
import com.ibm.wala.ipa.slicer.NormalStatement;
import com.ibm.wala.ipa.slicer.SDG;
import com.ibm.wala.ipa.slicer.Slicer;
import com.ibm.wala.ipa.slicer.Statement;
import com.ibm.wala.ssa.SSAInstruction;
import com.ibm.wala.ssa.SSAInvokeInstruction;
import com.ibm.wala.types.ClassLoaderReference;
import com.ibm.wala.types.MethodReference;
import com.ibm.wala.util.CancelException;
import com.ibm.wala.util.collections.Pair;
import edu.rit.se.design.callgraph.analysis.AbstractSerializationCallGraphBuilder;
import edu.rit.se.design.callgraph.analysis.PointerAnalysisPolicy;
import edu.rit.se.design.callgraph.evaluation.rq1_rq2.soundness_precision.XCorpusSoundnessTest;
import edu.rit.se.design.callgraph.evaluation.utils.YSoSerialTestCases;
import edu.rit.se.design.dodo.utils.graphs.IPathFinderIterative;
import edu.rit.se.design.dodo.utils.graphs.TrieBasedBFSPathFinderIterative;
import edu.rit.se.design.dodo.utils.wala.MethodDescriptorsLoader;
import edu.rit.se.design.dodo.utils.wala.SinkDescriptor;
import org.apache.commons.io.FileUtils;
import org.junit.jupiter.api.DynamicTest;
import org.junit.jupiter.api.TestFactory;

import java.io.File;
import java.io.IOException;
import java.util.*;
import java.util.function.Predicate;

import static edu.rit.se.design.callgraph.analysis.PointerAnalysisPolicy.PolicyType.ZeroXCFA;
import static edu.rit.se.design.callgraph.evaluation.rq1_rq2.soundness_precision.XCorpusSoundnessTest.*;
import static edu.rit.se.design.callgraph.evaluation.utils.TestUtilities.*;
import static edu.rit.se.design.callgraph.util.AnalysisUtils.*;
import static java.lang.String.join;


/**
 * Test each approach's ability to find vulnerabilities in the corpus.
 *
 * @author Joanna C. S. Santos
 */
public class VulnerabilityFindingTest {
    public static String[] projects = new String[]{
            YSoSerialTestCases.ROME,
            YSoSerialTestCases.FILEUPLOAD1,
            YSoSerialTestCases.BEANSHELL1,
            YSoSerialTestCases.WICKET1,
            YSoSerialTestCases.COMMONS_COLLECTIONS6,
            YSoSerialTestCases.COMMONS_COLLECTIONS1,
            YSoSerialTestCases.COMMONS_COLLECTIONS7,
            YSoSerialTestCases.COMMONS_COLLECTIONS5,
            YSoSerialTestCases.COMMONS_COLLECTIONS3,
            YSoSerialTestCases.COMMONS_COLLECTIONS2,
            YSoSerialTestCases.COMMONS_COLLECTIONS4,
            YSoSerialTestCases.JBOSS_INTERCEPTORS1,
            YSoSerialTestCases.CLICK1,
            YSoSerialTestCases.COMMONS_BEAN_UTILS1,
            YSoSerialTestCases.MOZILLA_RHINO1,
            YSoSerialTestCases.MOZILLA_RHINO2,
            YSoSerialTestCases.C3P0,
            YSoSerialTestCases.SPRING2,
            YSoSerialTestCases.JAVASSIST_WELD1,
            YSoSerialTestCases.SPRING1,
            YSoSerialTestCases.JSON1,
            YSoSerialTestCases.ASPECTJWEAVER,
            YSoSerialTestCases.VAADIN1,
            YSoSerialTestCases.CLOJURE,
            YSoSerialTestCases.GROOVY1,
            YSoSerialTestCases.JYTHON1,
    };

    @TestFactory
    public Collection<DynamicTest> soundnessTests() throws IOException {
        List<SinkDescriptor> sinkDescriptors = MethodDescriptorsLoader.loadSinksFromCsv(new File("../../config/sinks.csv"), true);

        Collection<DynamicTest> dynamicTests = new ArrayList<>();

        for (String projectPath : projects) {
            for (XCorpusSoundnessTest.Approach algorithm : Arrays.asList(/*Approach.SALSA,*/ Approach.SENECA)) {
                for (PointerAnalysisPolicy policy : Arrays.asList(new PointerAnalysisPolicy(ZeroXCFA, 1))) {
                    String projectName = getProjectName(projectPath);
                    String approachName = algorithm.toString();
                    String testName = join("_", projectName, approachName, policy.toString());
                    DynamicTest dTest = DynamicTest.dynamicTest(testName, () -> {
                        Pair<SDG<InstanceKey>, AbstractSerializationCallGraphBuilder> p = computeSDG(projectPath, algorithm, policy);
                        SDG sdg = p.fst;
                        AbstractSerializationCallGraphBuilder builder = p.snd;
                        List<Statement> sinkStatements = findSinks(sdg, sinkDescriptors);

                        List<VulnerablePath> vulnerablePaths = findAll(builder.getCallGraph(), builder, sinkStatements);
                        StringBuilder results = new StringBuilder();
                        results.append("[\n");
                        for (int i = 0; i < vulnerablePaths.size(); i++) {
                            VulnerablePath vulnerablePath = vulnerablePaths.get(i);
                            results.append("\t").append(vulnerablePath.toString());
                            if (i < vulnerablePaths.size() - 1) {
                                results.append(",");
                            }
                            results.append("\n");
                        }
                        results.append("]");


                        // writes the results
                        String fileName = join("_", projectName, approachName, policy.toString(), "vuln_paths.jsonl");
                        FileUtils.write(new File(VULN_PATHS_FOLDER, fileName), results.toString(), "UTF-8");
                    });
                    dynamicTests.add(dTest);
                }
            }
        }
        return dynamicTests;
    }

    /**
     * Given the project path, approach and pointer analysis policy, computes the SDG for the project.
     *
     * @param projectPath path to the YSoSerial project where we will find the JAR files added to the extension scope.
     * @param approach    the approach to be used to compute the call graph (eg {@link Approach#SENECA}).
     * @param policy      the pointer analysis policy to be used to compute the call graph (see {@link PointerAnalysisPolicy}).
     * @return the SDG for the project.
     * @throws ClassHierarchyException         if the class hierarchy could not be computed.
     * @throws IOException                     if the exclusions file could not be read.
     * @throws CallGraphBuilderCancelException if the call graph could not be computed.
     */
    public Pair<SDG<InstanceKey>, AbstractSerializationCallGraphBuilder> computeSDG(String projectPath, Approach approach, PointerAnalysisPolicy policy) throws ClassHierarchyException, IOException, CallGraphBuilderCancelException {
        File exclusions = new File(EXCLUSIONS_FILE);
        AnalysisScope scope = makeAnalysisScope(DRIVER_CLASS, exclusions, new File(projectPath));
        IClassHierarchy cha = makeIClassHierarchy(scope);
        AnalysisOptions options = makeAnalysisOptions(scope, cha);
        AnalysisCache cache = makeAnalysisCache();

        // compute call graph
        CallGraphBuilder builder = getCallgraphBuilder(approach, policy, scope, options, cache, cha);
        CallGraph cg = builder.makeCallGraph(options, null);

        // compute SDG
        SDG<InstanceKey> sdg = new SDG(cg, builder.getPointerAnalysis(), Slicer.DataDependenceOptions.NONE, Slicer.ControlDependenceOptions.NO_EXCEPTIONAL_EDGES);

        return Pair.make(sdg, ((AbstractSerializationCallGraphBuilder) builder));
    }


    private static List<Statement> findSinks(SDG<InstanceKey> sdg, List<SinkDescriptor> sinkDescriptors) {
        List<Statement> sinks = new ArrayList<>();
        for (Statement s : sdg) {
            if (s.getKind().equals(Statement.Kind.NORMAL) && !s.getNode().getMethod().getDeclaringClass().getClassLoader().getReference().equals(ClassLoaderReference.Primordial)) {
                SSAInstruction instruction = ((NormalStatement) s).getInstruction();
                if (instruction instanceof SSAInvokeInstruction) {
                    MethodReference declaredTarget = ((SSAInvokeInstruction) instruction).getDeclaredTarget();
                    sinkDescriptors.parallelStream()
                            .filter(sinkDesc -> sinkDesc.getMethodRef().getSignature().equals(declaredTarget.getSignature()))
                            .forEach(desc -> sinks.add(s));

                }
            }
        }
        return sinks;
    }


    public List<VulnerablePath> findAll(CallGraph cg, AbstractSerializationCallGraphBuilder builder, List<Statement> sinkStatements) throws CancelException {
        List<VulnerablePath> results = new ArrayList<>();


        int pathSizeThreshold = 100;
        // magic methods
        Set<CGNode> magicMethods = builder.getMagicMethods();
        int sinkNo = 0, nPaths = 0;
        for (Statement sinkStatement : sinkStatements) {
            sinkNo++;
            Predicate<CGNode> p = node -> node.equals(sinkStatement.getNode());
            IPathFinderIterative<CGNode> finder = new TrieBasedBFSPathFinderIterative<CGNode>(cg, p, magicMethods.iterator(), pathSizeThreshold);
            List<CGNode> path;
            while ((path = finder.find()) != null && path.size() > 1)
                results.add(new VulnerablePath(String.format("%d.%d", sinkNo, ++nPaths), path));
        }
        return results;
    }


    static class VulnerablePath {

        // required fields
        public final String id;
        public final List<CGNode> path;

        VulnerablePath(String pathId, List<CGNode> path) {
            this.id = pathId;
            this.path = path;
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();

            sb.append("\"id\":\"");
            sb.append(id);
            sb.append("\",\"path\":[");
            for (int i = 0; i < path.size(); i++) {
                CGNode node = path.get(i);
                sb.append("{");
                sb.append("\"nodeId\":\"");
                sb.append(node.getGraphNodeId());
                sb.append("\",\"method\":\"");
                sb.append(node.getMethod().getReference().getSignature());
                sb.append("\",\"context\":\"");
                sb.append(node.getContext());
                sb.append("\"}");
                if (i < path.size() - 1)
                    sb.append(",");
            }
            sb.append("]");


            return "{" + sb + "}";
        }
    }
}
