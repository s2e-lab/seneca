package edu.rit.se.design.callgraph.evaluation.rq4.vulnerability;


import com.ibm.wala.ipa.callgraph.*;
import com.ibm.wala.ipa.cha.ClassHierarchyException;
import com.ibm.wala.ipa.cha.IClassHierarchy;
import com.ibm.wala.util.CancelException;
import com.ibm.wala.util.graph.impl.GraphInverter;
import com.ibm.wala.util.graph.traverse.BFSIterator;
import edu.rit.se.design.callgraph.analysis.AbstractSerializationCallGraphBuilder;
import edu.rit.se.design.callgraph.analysis.PointerAnalysisPolicy;
import edu.rit.se.design.callgraph.evaluation.rq1_rq2.soundness_precision.XCorpusSoundnessTest;
import edu.rit.se.design.callgraph.evaluation.utils.YSoSerialTestCases;
import edu.rit.se.design.dodo.utils.ResourceLoader;
import edu.rit.se.design.dodo.utils.graphs.TrieBasedBFSPathFinderIterative;
import edu.rit.se.design.dodo.utils.wala.MethodDescriptorsLoader;
import edu.rit.se.design.dodo.utils.wala.SinkDescriptor;
import edu.rit.se.design.dodo.utils.wala.WalaUtils;
import org.apache.commons.io.FileUtils;
import org.junit.jupiter.api.DynamicTest;
import org.junit.jupiter.api.TestFactory;

import java.io.File;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.function.Predicate;

import static edu.rit.se.design.callgraph.analysis.PointerAnalysisPolicy.PolicyType.nCFA;
import static edu.rit.se.design.callgraph.evaluation.rq1_rq2.soundness_precision.XCorpusSoundnessTest.*;
import static edu.rit.se.design.callgraph.evaluation.utils.TestUtilities.*;
import static edu.rit.se.design.callgraph.util.AnalysisUtils.*;
import static java.lang.String.join;


/**
 * Test each approach's ability to find vulnerabilities in the corpus.
 *
 * @author Joanna C. S. Santos
 */
public class SimplerVulnerabilityFindingTest {
    public static String[] projects = new String[]{
            YSoSerialTestCases.ROME,
            YSoSerialTestCases.FILEUPLOAD1,
            YSoSerialTestCases.BEANSHELL1,
            YSoSerialTestCases.WICKET1,
            YSoSerialTestCases.COMMONS_COLLECTIONS6,
            YSoSerialTestCases.COMMONS_COLLECTIONS1,
            YSoSerialTestCases.COMMONS_COLLECTIONS7,
            YSoSerialTestCases.COMMONS_COLLECTIONS5,
            YSoSerialTestCases.COMMONS_COLLECTIONS3,
            YSoSerialTestCases.CLICK1,
            YSoSerialTestCases.COMMONS_BEAN_UTILS1,
            YSoSerialTestCases.C3P0,
            YSoSerialTestCases.SPRING1,
            YSoSerialTestCases.ASPECTJWEAVER,
            YSoSerialTestCases.VAADIN1,
            YSoSerialTestCases.GROOVY1,
            YSoSerialTestCases.JYTHON1,
    };

    @TestFactory
    public Collection<DynamicTest> soundnessTests() throws IOException {
        File sinksCsv = ResourceLoader.getResourceFile("/config/sinks.csv");
        List<SinkDescriptor> sinkDescriptors = MethodDescriptorsLoader.loadSinksFromCsv(sinksCsv, true);

        Collection<DynamicTest> dynamicTests = new ArrayList<>();

        for (String projectPath : projects) {
            for (XCorpusSoundnessTest.Approach algorithm : Arrays.asList(Approach.SENECA)) {
                for (PointerAnalysisPolicy policy : Arrays.asList(new PointerAnalysisPolicy(nCFA, 1))) {
                    String projectName = getProjectName(projectPath);
                    String approachName = algorithm.toString();
                    String testName = join("_", projectName, approachName, policy.toString());
                    DynamicTest dTest = DynamicTest.dynamicTest(testName, () -> {

                        AbstractSerializationCallGraphBuilder builder = computeCallGraph(projectPath, algorithm, policy);
                        System.out.println("Built call graph");
                        List<CGNode> sinkNodes = findSinks(builder.getCallGraph(), sinkDescriptors);
                        System.out.println("Found sinks");
                        List<VulnerablePath> vulnerablePaths = findAll(builder.getCallGraph(), builder, sinkNodes);
                        System.out.println("Found paths");
                        StringBuilder results = new StringBuilder();
                        results.append("[\n");
                        for (int i = 0; i < vulnerablePaths.size(); i++) {
                            VulnerablePath vulnerablePath = vulnerablePaths.get(i);
                            results.append("\t").append(vulnerablePath.toString());
                            if (i < vulnerablePaths.size() - 1) {
                                results.append(",");
                            }
                            results.append("\n");
                        }
                        results.append("]");


                        // writes the results
                        String fileName = join("_", projectName, approachName, policy.toString(), "vuln_paths.json");
                        FileUtils.write(new File(VULN_PATHS_FOLDER, fileName), results.toString(), "UTF-8");
                    });

                    dynamicTests.add(dTest);
                }
            }
        }
        return dynamicTests;
    }

    /**
     * Given the project path, approach and pointer analysis policy, computes the SDG for the project.
     *
     * @param projectPath path to the YSoSerial project where we will find the JAR files added to the extension scope.
     * @param approach    the approach to be used to compute the call graph (eg {@link Approach#SENECA}).
     * @param policy      the pointer analysis policy to be used to compute the call graph (see {@link PointerAnalysisPolicy}).
     * @return the SDG for the project.
     * @throws ClassHierarchyException         if the class hierarchy could not be computed.
     * @throws IOException                     if the exclusions file could not be read.
     * @throws CallGraphBuilderCancelException if the call graph could not be computed.
     */
    public AbstractSerializationCallGraphBuilder computeCallGraph(String projectPath, Approach approach, PointerAnalysisPolicy policy) throws ClassHierarchyException, IOException, CallGraphBuilderCancelException {
        File exclusions = new File(EXCLUSIONS_FILE);
        AnalysisScope scope = makeAnalysisScope(DRIVER_CLASS, exclusions, new File(projectPath));
        IClassHierarchy cha = makeIClassHierarchy(scope);
        AnalysisOptions options = makeAnalysisOptions(scope, cha);
        AnalysisCache cache = makeAnalysisCache();

        // compute call graph
        CallGraphBuilder builder = getCallgraphBuilder(approach, policy, scope, options, cache, cha);
        CallGraph cg = builder.makeCallGraph(options, null);

        return ((AbstractSerializationCallGraphBuilder) builder);
    }

    /**
     * Given a call graph, a call graph builder and a list of sink statements, finds all methods that invoke sinks paths in the call graph.
     *
     * @param cg              call graph.
     * @param sinkDescriptors list of sink descriptors.
     * @return
     */
    private static List<CGNode> findSinks(CallGraph cg, List<SinkDescriptor> sinkDescriptors) {
        List<CGNode> sinks = new ArrayList<>();

        for (CGNode cgNode : cg) {
            boolean passVibeCheck = false;
            // only if at least one predecessor is not primordial
            Iterator<CGNode> predNodes = cg.getPredNodes(cgNode);
            while (predNodes.hasNext()) {
                CGNode pred = predNodes.next();
                if (!WalaUtils.isPrimordialScope(pred)) {
                    passVibeCheck = true;
                    break;
                }
            }

            if (passVibeCheck)
                sinkDescriptors.parallelStream()
                        .filter(sinkDesc -> sinkDesc.getMethodRef().getSignature().equals(cgNode.getMethod().getReference().getSignature()))
                        .forEach(desc -> sinks.add(cgNode));
        }

        return sinks;
    }


    public static Set<CGNode> backwardSlice(CallGraph cg, CGNode root) {
        Set<CGNode> slice = new HashSet<>();
        new BFSIterator<>(GraphInverter.invert(cg))
                .forEachRemaining(n -> {
//                    if(!WalaUtils.isPrimordialScope(n))
                    slice.add(n);
                });

        return slice;
    }

    public List<VulnerablePath> findAll(CallGraph cg, AbstractSerializationCallGraphBuilder builder, List<CGNode> sinkStatements) throws CancelException {
        List<VulnerablePath> results = new ArrayList<>();
        Callable<Void> callable = new Callable<Void>() {
            @Override
            public Void call() throws Exception {
                int pathSizeThreshold = 15;
                // magic methods
                Set<CGNode> magicMethods = builder.getMagicMethods();
                int sinkNo = 0, nPaths = 0;
                for (CGNode sinkStatement : sinkStatements) {
                    sinkNo++;
                    Predicate<CGNode> p = node -> node.equals(sinkStatement);
                    Set<CGNode> backwardSlice = backwardSlice(cg, sinkStatement);
                    TrieBasedBFSPathFinderIterative<CGNode> finder = new TrieBasedBFSPathFinderIterative<CGNode>(cg, p, magicMethods.iterator(), pathSizeThreshold);
                    finder.setSlice(backwardSlice);
                    List<CGNode> path;
                    while ((path = finder.find()) != null && path.size() > 1) {
                        System.out.println(path.size() + "\t" + sinkStatement.getMethod().getSignature());
                        results.add(new VulnerablePath(String.format("%d.%d", sinkNo, ++nPaths), path));
                    }
                }
                return null;
            }
        };


        ExecutorService executor = Executors.newSingleThreadExecutor();
        try {
            executor.invokeAll(Arrays.asList(callable), 5, TimeUnit.MINUTES);
            executor.shutdown();
        } catch (Exception e) {
            System.err.println(e.getMessage());
        }


        return results;
    }


    static class VulnerablePath {

        // required fields
        public final String id;
        public final List<CGNode> path;

        VulnerablePath(String pathId, List<CGNode> path) {
            this.id = pathId;
            this.path = path;
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();

            sb.append("\"id\":\"");
            sb.append(id);
            sb.append("\",\"path\":[");
            for (int i = 0; i < path.size(); i++) {
                CGNode node = path.get(i);
                sb.append("{");
                sb.append("\"nodeId\":\"");
                sb.append(node.getGraphNodeId());
                sb.append("\",\"method\":\"");
                sb.append(node.getMethod().getReference().getSignature());
                sb.append("\",\"scope\":\"");
                sb.append(node.getMethod().getDeclaringClass().getClassLoader().getReference().getName());
                sb.append("\",\"context\":\"");
                sb.append(node.getContext());
                sb.append("\"}");
                if (i < path.size() - 1)
                    sb.append(",");
            }
            sb.append("]");


            return "{" + sb + "}";
        }
    }
}
